class VariableInfo {
  member:
    int value;
    boolean canRead = true;
    int readLock = 0;
    boolean writeLock = false;  
  
  function init(v) {
    value = v;
  }
}

class Variable {
  member:
    int variableNumber
    hashmap values[siteNumber, VariableInfo];

  function init(n) {
    variableNumber = n;
    value = 10 * n;
    if (n is odd) {
      int siteNumber = (n + 1) mod 10;
      VariableInfo vi = new VariableInfo(value);
      values[siteNumber] = vi;
    }
    else if (n is even) {
      for (int i = 1; i <= 10; i++) {
        VariableInfo vi = new VariableInfo(value);
        values[i] = vi;
      }
    }
  }
  
  function print() {
    for (each element in hashmap) {
      print ("x" + variableNumber + "." + element[0] + 
             "=" + elememt[1][0]); // element[1][0] is the value
    }
  }
}

class Site {
  member:
    int siteNumber;
    array variables[];
    bool available = True;

  function init(n, v[]) {
    siteNumber = n;
    variables[] = v[];
    // e.g.
    // s2[] = [x1, x11, x2, x4, x6, x8, x10];
  }
  
  function print() {
    for (each x in variables[]) {
      print ("x" + x.variableNumber + "." + siteNumber +
             " = " + x.values[siteNumber][0]);
      // values[siteNumber] is a pair (value, canRead)
    }
  }
}

class Database {
  member:
    array sites[];
  
  function init(s[]) {
    sites[] = s;
    // e.g.
    // sites[] = [1, 2, .. , 10];
  }
  
  function print() {
    for (each site in sites) {
      print ("site" + site.siteNumber + ": ");
      site.print();
    }
  }
}

class Lock {
  member:
    string variable;
    int siteNumber
    string type; // write or read
  
  function init(v, t) {
    variable = v;
    type = t;
  }
}

class Version {
  member:
    int versionNumber;
    hashmap variables[];
    array involvedTransaction[];
  
  function init(n, v[]) {
    versionNumber = n;
    variables[] = v[];
  }
}

class Transaction {
  member:
    array locks[];
    hashmap writeVariables[name, value];
    int versionNumber = -1; // for read-only transaction, -1 by default
  
  function init(isReadOnly) {
    if (isReadOnly) {
      versionNumber = latestVersionNumber;
    }
  }
}

function runTest(file) {    
  create variables x1~x20;
  create site s1~s10;
  create variableMap = { 'x1': x1, 'x2': x2, ... };
  create siteMap = { 's1': s1, 's2': s2, ... }
  command.split().substring(1)
  create database;
  create multiVersion[versionNumber, version];
  create int latestVersionNumber;
  create hashmap transactionMap[transactionString, transaction];
  create array waitList[string: command];
  create array transactionAge[transaction number];

  for (each newline in the file) {
    // cycle detection
    if (waitList.size > 1) {
      list result = cycleDetection(waitList);
      // if find a cycle
      // then abort the youngest transaction
      if (result) {
        use transactionAge table to find
          the youngest transaction T in the result;
        abort(T);
      }
    }
    create array waitListAppend[transaction number];
    // execute input commands
    for (each command in the line) {
      execute corresponding function;
      string functionName = command.split("(")(0)
      switch (functionName) {
        case "R": 
        case "W":
        case "recover": 
        case "dump": {
          string parameter = command.split("(")(1).split(")")(0);
          if (parameter.size == 0) {
            dump();
          }
          else if (parameter[0] != "x") {
            dumpSite(parameter)
          }
          else if (parameter[0] == "x") {
            
          }
        }
      }
      if (execute fail) {
        waitListAppend.push(command);
      }
    }
    // execute accumulate input commands
    // be careful with read locks
    // if the order is T1 and T2
    // and T1 wants a write lock on x, T2 wants a read lock on x
    // then we can't skip T1 and give T2 the read lock
    for (each command in the waitList) {
      execute corresponding function;
      if (execute success) {
        delete command from waitList;
      }
    }
    waitList.append(waitListAppend);
  }
  return;
}

main {
  runTest(file);
}